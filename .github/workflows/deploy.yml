name: Deploy Quarto Website - NO JEKYLL

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    env:
      JEKYLL_ENV: "disabled"
      DISABLE_JEKYLL: "true"
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Remove docs directory completely
        run: |
          echo "ðŸ—‘ï¸  SUPPRESSION COMPLÃˆTE du dossier docs..."
          rm -rf docs/ _site/ 2>/dev/null || true
          echo "âœ… NettoyÃ©"

      - name: Setup Quarto
        uses: quarto-dev/quarto-actions/setup@v2

      # CACHE pour Python packages
      - name: Cache pip packages
        uses: actions/cache@v3
        id: cache-pip
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('.github/workflows/deploy.yml') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install Python and Jupyter
        run: |
          python3 -m pip install --upgrade pip
          python3 -m pip install jupyter nbformat ipykernel jupyter-cache

      - name: Setup R for binary packages
        uses: r-lib/actions/setup-r@v2
        with:
          r-version: '4.3'

      # CACHE pour R packages
      - name: Cache R packages
        uses: actions/cache@v3
        id: cache-r
        with:
          path: |
            /usr/local/lib/R/site-library
            ~/.R/library
            ~/R/library
          key: ${{ runner.os }}-r4.3-packages-${{ hashFiles('.github/workflows/deploy.yml') }}
          restore-keys: |
            ${{ runner.os }}-r4.3-packages-

      # Ã‰TAPE CRITIQUE : Installation R depuis BINAIRES SEULEMENT
      - name: Install R packages FROM BINARIES (NO SOURCE COMPILATION)
        if: steps.cache-r.outputs.cache-hit != 'true'
        run: |
          echo "âš¡âš¡âš¡ INSTALLATION R - BINAIRES UNIQUEMENT âš¡âš¡âš¡"
          echo "âš ï¸  COMPILATION SOURCE : DÃ‰SACTIVÃ‰E"
          
          # Configuration AGGRESSIVE pour binaires
          cat > ~/.Rprofile << 'EOF'
          # =================================================
          # CONFIGURATION ULTRA-OPTIMISÃ‰E POUR BINAIRES
          # =================================================
          
          # 1. DÃ‰SACTIVER TOUTE COMPILATION
          options(
            # NE JAMAIS compiler depuis les sources
            install.packages.compile.from.source = "never",
            # Ne pas vÃ©rifier les sources
            install.packages.check.source = "no",
            # Installation parallÃ¨le maximale
            Ncpus = 6,
            # Timeout long pour gros packages
            timeout = 300,
            # Options d'installation POUR BINAIRES
            INSTALL_opts = c(
              "--no-multiarch",
              "--no-docs", 
              "--no-test-load",
              "--no-byte-compile",
              "--no-staged-install",
              "--no-data"
            )
          )
          
          # 2. UTILISER RSPM POUR BINAIRES UBUNTU 22.04
          # RStudio Package Manager - binaires prÃ©-compilÃ©s
          ubuntu_codename <- "jammy"  # Ubuntu 22.04
          rspm_url <- paste0(
            "https://packagemanager.rstudio.com/cran/__linux__/",
            ubuntu_codename,
            "/latest"
          )
          
          # DÃ©finir comme dÃ©pÃ´t PRINCIPAL
          options(repos = c(RSPM = rspm_url))
          
          cat("\n")
          cat("=========================================\n")
          cat("ðŸŽ¯ MODE BINAIRE FORCÃ‰ ACTIVÃ‰\n")
          cat("ðŸ”§ DÃ©pÃ´t :", rspm_url, "\n")
          cat("ðŸš« Compilation source : INTERDITE\n")
          cat("âš¡ Ncpus :", getOption("Ncpus"), "\n")
          cat("=========================================\n")
          EOF
          
          # VÃ‰RIFIER LA CONFIGURATION
          echo "ðŸ” VÃ©rification configuration R..."
          Rscript -e "
          cat('\n=== CONFIGURATION ACTIVE ===\n')
          cat('1. DÃ©pÃ´t      :', getOption('repos')[1], '\n')
          cat('2. Compilation:', getOption('install.packages.compile.from.source'), '\n')
          cat('3. Ncpus      :', getOption('Ncpus'), '\n')
          cat('4. INSTALL_opts:', paste(getOption('INSTALL_opts'), collapse=', '), '\n')
          cat('=============================\n')
          "
          
          # LISTE DES PACKAGES (optimisÃ©e pour vitesse)
          Rscript -e "
          start_time <- Sys.time()
          cat('ðŸ“¦ DÃ©but de l\'installation des packages R...\n\n')
          
          # Packages par groupe (installation plus stable)
          groups <- list(
            'Groupe 1 - Core' = c('rmarkdown', 'knitr'),
            'Groupe 2 - Tidyverse' = c('dplyr', 'ggplot2', 'tidyr'),
            'Groupe 3 - Data I/O' = c('readxl', 'lubridate'),
            'Groupe 4 - Stats' = c('car', 'lmtest', 'gplots')
          )
          
          # Fonction d'installation avec retry
          install_group <- function(pkgs, group_name, max_retries = 2) {
            cat('\n---', group_name, '---\n')
            
            for (retry in 1:max_retries) {
              tryCatch({
                cat('Tentative', retry, ': ', paste(pkgs, collapse=', '), '\n')
                
                # Essayer d'abord avec type='binary'
                result <- tryCatch({
                  install.packages(pkgs, type = 'binary', quiet = TRUE)
                  'âœ… Binaire'
                }, error = function(e1) {
                  # Fallback sans type='binary' mais avec options anti-compilation
                  install.packages(pkgs, quiet = TRUE)
                  'âš ï¸  Standard (fallback)'
                })
                
                cat('SuccÃ¨s :', result, '\n')
                return(TRUE)
                
              }, error = function(e) {
                if (retry == max_retries) {
                  cat('âŒ Ã‰chec aprÃ¨s', max_retries, 'tentatives\n')
                  cat('Erreur :', e$message, '\n')
                  return(FALSE)
                }
                cat('â±ï¸  Pause de 5 secondes avant rÃ©essai...\n')
                Sys.sleep(5)
              })
            }
          }
          
          # Installer chaque groupe
          for (group_name in names(groups)) {
            install_group(groups[[group_name]], group_name)
          }
          
          # VÃ‰RIFICATION FINALE
          cat('\n=== VÃ‰RIFICATION DES INSTALLATIONS ===\n')
          all_pkgs <- unlist(groups, use.names = FALSE)
          installed <- rownames(installed.packages())
          
          success_count <- 0
          for (pkg in all_pkgs) {
            if (pkg %in% installed) {
              version <- packageVersion(pkg)
              cat('âœ“', pkg, 'v', as.character(version), '\n')
              success_count <- success_count + 1
            } else {
              cat('âœ—', pkg, 'MANQUANT\n')
            }
          }
          
          end_time <- Sys.time()
          total_time <- round(difftime(end_time, start_time, units = 'secs'), 1)
          
          cat('\nðŸ“Š RÃ‰SUMÃ‰ :\n')
          cat('  Packages :', success_count, '/', length(all_pkgs), '\n')
          cat('  Temps    :', total_time, 'secondes\n')
          
          if (success_count == length(all_pkgs)) {
            cat('ðŸŽ¯ SUCCÃˆS COMPLET\n')
          } else {
            cat('âš ï¸  ATTENTION : Certains packages manquent\n')
          }
          "
          
          echo "âœ… Installation R terminÃ©e"

      # CACHE pour TinyTeX (partagÃ© avec le workflow PDFs)
      - name: Cache TinyTeX
        uses: actions/cache@v3
        id: cache-tinytex
        with:
          path: ~/.TinyTeX
          key: ${{ runner.os }}-tinytex-shared
          restore-keys: |
            ${{ runner.os }}-tinytex-

      # Installer TinyTeX seulement si pas dans le cache
      - name: Install TinyTeX for LaTeX formulas
        if: steps.cache-tinytex.outputs.cache-hit != 'true'
        run: |
          echo "ðŸ“„ Installation de TinyTeX pour les formules..."
          
          # 1. Installer TinyTeX
          wget -qO- "https://yihui.org/tinytex/install-unx.sh" | sh
          
          # 2. Ajouter au PATH
          echo "$HOME/.TinyTeX/bin/x86_64-linux" >> $GITHUB_PATH
          
          # 3. Attendre que le PATH soit mis Ã  jour
          export PATH="$HOME/.TinyTeX/bin/x86_64-linux:$PATH"
          
          # 4. Mettre Ã  jour tlmgr et installer les packages manquants
          tlmgr update --self
          tlmgr install \
            array \
            subcaption \
            booktabs \
            float \
            geometry \
            hyperref \
            caption \
            fancyhdr \
            microtype \
            wrapfig \
            amsmath \
            amsfonts \
            amssymb \
            || echo "âš ï¸ Certains packages dÃ©jÃ  installÃ©s"
          
          # 5. VÃ©rifier l'installation
          which pdflatex
          pdflatex --version
          echo "âœ… TinyTeX installÃ©"

      # S'assurer que le PATH TinyTeX est disponible mÃªme avec cache
      - name: Setup LaTeX PATH
        run: |
          export PATH="$HOME/.TinyTeX/bin/x86_64-linux:$PATH"
          echo "$HOME/.TinyTeX/bin/x86_64-linux" >> $GITHUB_PATH
          echo "ðŸ” VÃ©rification pdflatex:"
          which pdflatex || echo "pdflatex pas encore dans PATH"

      # CACHE pour le rendu Quarto
      - name: Cache Quarto output
        uses: actions/cache@v3
        id: cache-quarto
        with:
          path: |
            docs/
            _freeze/
            .quarto-cache/
          key: ${{ runner.os }}-quarto-${{ hashFiles('**/*.qmd', '**/_quarto.yml', '**/*.bib', '**/*.csl') }}
          restore-keys: |
            ${{ runner.os }}-quarto-

      - name: Render Quarto website
        run: |
          echo "ðŸš€ Rendu du site Quarto..."
          
          # Si pas de cache, faire un rendu complet
          if [ "${{ steps.cache-quarto.outputs.cache-hit }}" != 'true' ]; then
            echo "ðŸ“ Rendu complet nÃ©cessaire..."
            quarto render --no-cache
          else
            echo "âœ… Utilisation du cache Quarto"
            # VÃ©rifier que docs/ existe depuis le cache
            if [ ! -d "docs" ]; then
              echo "âš ï¸  Cache prÃ©sent mais docs/ manquant, rendu complet..."
              quarto render --no-cache
            fi
          fi
          
          echo "âœ… Rendu terminÃ©"

      # Ã‰TAPE CRITIQUE : Post-traitement SANS JEKYLL
      - name: Post-process to ELIMINATE Jekyll
        run: |
          echo "ðŸ›‘ Ã‰LIMINATION DÃ‰FINITIVE DE JEKYLL..."
          
          # S'assurer que docs/ existe
          if [ ! -d "docs" ]; then
            echo "âŒ ERREUR : docs/ non trouvÃ© aprÃ¨s rendu"
            exit 1
          fi
          
          # 1. CRÃ‰ER .nojekyll EXPLICITE
          echo "# ===========================================" > docs/.nojekyll
          echo "# JEKYLL COMPLETELY DISABLED" >> docs/.nojekyll
          echo "# This is a static HTML site" >> docs/.nojekyll
          echo "# GitHub Pages: DO NOT PROCESS WITH JEKYLL" >> docs/.nojekyll
          echo "# Generated by Quarto on $(date)" >> docs/.nojekyll
          echo "# ===========================================" >> docs/.nojekyll
          
          # 2. SUPPRIMER TOUS LES FICHIERS .scss/.sass
          echo "ðŸ”ª Suppression des fichiers SCSS/SASS..."
          scss_files=$(find docs -name "*.scss" -o -name "*.sass" 2>/dev/null | wc -l)
          echo "Fichiers trouvÃ©s: $scss_files"
          
          if [ "$scss_files" -gt 0 ]; then
            find docs -name "*.scss" -type f -delete
            find docs -name "*.sass" -type f -delete
            echo "âœ… Fichiers supprimÃ©s"
          fi
          
          # 3. Renommer index
          if [ -f "docs/index.qmd.html" ]; then
            mv docs/index.qmd.html docs/index.html
            echo "âœ… index.qmd.html â†’ index.html"
          fi
          
          # 4. VÃ‰RIFICATION FINALE
          echo "ðŸ” VÃ‰RIFICATION FINALE :"
          echo "  - .nojekyll prÃ©sent: $(test -f docs/.nojekyll && echo 'OUI' || echo 'NON')"
          echo "  - Fichiers .scss restants: $(find docs -name '*.scss' 2>/dev/null | wc -l)"
          echo "  - Fichiers .sass restants: $(find docs -name '*.sass' 2>/dev/null | wc -l)"

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./docs
          publish_branch: gh-pages  # Branche standard pour GitHub Pages
          force_orphan: true
          keep_files: false
          user_name: 'github-actions[bot]'
          user_email: 'github-actions[bot]@users.noreply.github.com'